//---------------------------------------------------------------------------------------------------------
// main.cpp
//---------------------------------------------------------------------------------------------------------
#include <cstdlib>
#include <dlfcn.h>
#include <stdexcept>

#include "dr4/event.hpp"
#include "dr4/math/color.hpp"
#include "dr4/window.hpp"
#include "misc/dr4_ifc.hpp"

using GetBackendT = dr4::DR4Backend* (*)();

int
main()
{
    // std::cout << "Hello world!";

    std::string libdr4Path( dr4::DR4BackendFunctionName );

    void* libdr4 = dlopen( "/home/sevsol/Projects/gfx/install/lib/libgfx.so", RTLD_LAZY );

    if ( !libdr4 )
    {
        throw std::runtime_error( "Can't open lib" );
    }

    dr4::DR4Backend* backend =
        reinterpret_cast<GetBackendT>( dlsym( libdr4, dr4::DR4BackendFunctionName ) )();

    if ( !backend )
    {
        throw std::runtime_error( "Can't get backend" );
    }

    dr4::Window* window = backend->CreateWindow();

    if ( !window )
    {
        throw std::runtime_error( "Can't get window" );
    }

    window->SetSize( { 500, 500 } );
    window->SetTitle( "0xCEBAEBA1DEDA" );

    window->Open();

    std::optional<dr4::Event> event = {};
    while ( window->IsOpen() )
    {

        while ( ( event = window->PollEvent() ) )
        {
            switch ( event->type )
            {
                case dr4::Event::Type::QUIT:
                    window->Close();
                    break;
                default:
                    break;
            }
        }

        window->Clear( dr4::Color( 100, 100, 100, 255 ) );

        window->Display();
    }

    delete backend;
    delete window;

    return EXIT_SUCCESS;
}

//---------------------------------------------------------------------------------------------------------
// window.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_WINDOW
#define I_DR4_WINDOW

#include <optional>
#include <string>

#include "dr4/event.hpp"
#include "dr4/math/color.hpp"
#include "dr4/math/vec2.hpp"
#include "dr4/texture.hpp"

namespace dr4 {

class Window {

    // Texture field

  public:
    virtual void
    SetTitle( const std::string& title ) = 0;
    virtual const std::string&
    GetTitle() const = 0;

    virtual Vec2f
    GetSize() const = 0;
    virtual void
    SetSize( const dr4::Vec2f& size );

    virtual void
    Open() = 0;
    virtual bool
    IsOpen() const = 0;
    virtual void
    Close() = 0;

    virtual void
    Clear( const Color& color ) = 0;
    virtual void
    Draw( const Texture& texture, Vec2f pos ) = 0;
    virtual void
    Display() = 0;

    virtual dr4::Texture*
    CreateTexture() = 0;

    virtual std::optional<Event>
    PollEvent() = 0;

    inline virtual ~Window() {};
};

}; // namespace dr4

#endif // I_DR4_WINDOW

//---------------------------------------------------------------------------------------------------------
// rect.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_MATH_RECT
#define I_DR4_MATH_RECT

#include "dr4/math/vec2.hpp"

namespace dr4 {

struct Rect2f {

    Vec2f pos, size;

    inline Rect2f(Vec2f pos, Vec2f size) 
        :pos(pos), size(size) {}

    inline Rect2f(float x, float y, float width, float height)
        :pos(Vec2f(x, y)), size(Vec2f(width, height)) {}

    bool Contains(Vec2f point) const;
};

}; // namespace dr4 

#endif // I_DR4_RECT

//---------------------------------------------------------------------------------------------------------
// vec2.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_MATH_VEC2
#define I_DR4_MATH_VEC2

namespace dr4 {

struct Vec2f
{

    float x, y;

    Vec2f() = default;

    Vec2f( float x, float y ) : x( x ), y( y ) {}

    inline Vec2f
    operator-()
    {
        return Vec2f( -x, -y );
    }
    inline Vec2f
    operator+( Vec2f other )
    {
        return Vec2f( x + other.x, y + other.y );
    }
    inline Vec2f
    operator-( Vec2f other )
    {
        return Vec2f( x - other.x, y - other.y );
    }
    inline Vec2f
    operator*( float k )
    {
        return Vec2f( x * k, y * k );
    }
    inline Vec2f
    operator/( float k )
    {
        return Vec2f( x / k, y / k );
    }

    Vec2f
    Clamped( Vec2f min, Vec2f max ) const;
};

}; // namespace dr4

#endif // I_DR4_VEC2

//---------------------------------------------------------------------------------------------------------
// color.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_MATH_COLOR
#define I_DR4_MATH_COLOR

#include <cstdint>

namespace dr4 {

struct Color {

    uint8_t r, g, b, a;

    inline Color(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
        :r(r), g(g), b(b), a(a) {}
};

}; // namespace dr4

#endif // I_DR4_COLOR

//---------------------------------------------------------------------------------------------------------
// texture.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_TEXTURE
#define I_DR4_TEXTURE

#include <string>

#include "dr4/math/color.hpp"
#include "dr4/math/rect.hpp"
#include "dr4/math/vec2.hpp"

namespace dr4 {

struct Rectangle {

    Rect2f rect;
    Color fill;
    float borderThickness = 0;
    Color borderColor = Color(255, 0, 0, 255);

};

struct Text {

    enum class VAlign {
        UNKNOWN = -1,
        TOP,
        MIDDLE,
        BASELINE,
        BOTTOM
    };

    const std::string text;
    Vec2f pos;
    Color color = Color(255, 0, 0, 255);
    float fontSize = 20;
    VAlign valign = VAlign::TOP;

    // TODO: return of GetBounds()?
    // virtual Rect2f GetBounds() const = 0;

};

class Texture {

public:

    virtual void SetSize(Vec2f size) = 0;
    virtual Vec2f GetSize() const = 0;
    virtual float GetWidth() const = 0;
    virtual float GetHeight() const = 0;

    virtual void Draw(const Rectangle &rect) = 0;
    virtual void Draw(const Text &text) = 0;
    virtual void Draw(const Texture &texture, const Vec2f &pos) = 0;

    inline virtual ~Texture() {};
};

}; // namespace dr4

#endif // I_DR4_TEXTURE

//---------------------------------------------------------------------------------------------------------
// event.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_EVENT
#define I_DR4_EVENT

#include "dr4/math/vec2.hpp"

namespace dr4 {

struct Event
{

    enum class Type {
        UNKNOWN,
        MOUSE_MOVE,
        MOUSE_DOWN,
        MOUSE_UP,
        MOUSE_WHEEL,
        KEY_DOWN,
        KEY_UP,
        QUIT
    };

    struct MouseMove
    {
        Vec2f pos;
    };

    struct MouseButton
    {
        int   button;
        bool  pressed;
        Vec2f pos;
    };

    struct MouseWheel
    {
        Vec2f delta;
        Vec2f pos;
    };

    // TODO: keys

    Type type;

    union {
        MouseMove   mouseMove;
        MouseButton mouseDown;
        MouseButton mouseUp;
        MouseWheel  mouseWheel;
    };
};

}; // namespace dr4

#endif

//---------------------------------------------------------------------------------------------------------
// plugin.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_CUM_PLUGIN
#define I_CUM_PLUGIN

#include <string>
#include <vector>

#include "cum/version.hpp"

namespace cum {

class Plugin {

public:

    virtual const std::string &GetName() const = 0;
    virtual const std::string &GetDescription() const = 0;
    virtual const PluginVersion &GetVersion() const = 0;

    // TODO: finish plugins interdependency
    virtual bool CheckCompatibles(const std::vector<Plugin*>) const = 0;
    

};

};

#endif

//---------------------------------------------------------------------------------------------------------
// version.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_CUM_VERSION
#define I_CUM_VERSION

namespace cum {

struct PluginVersion { int major, minor, patch; };

};

#endif

//---------------------------------------------------------------------------------------------------------
// dr4_ifc.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_DR4_IFC
#define I_DR4_IFC

#include "dr4/window.hpp"

namespace dr4 {

/**
 * @brief DR4 backend interface
 *
 * To be rewritten later to use approporiate plugin system.
 */
class DR4Backend {

public:

    virtual const std::string &Name() const = 0;
    virtual dr4::Window *CreateWindow() = 0;
    inline virtual ~DR4Backend() {};

};


/**
 * @brief Name of a function all DR4 backend plugins must export
 * 
 * It's signature is:
 *      
 *      extern "C" DR4Backend* DR4_BACKEND_FUNCTION(void);
 *
 * Created object must be free'd with `delete` when it is not
 * needed anymore.
 *
 */
static const char *DR4BackendFunctionName = "CreateDR4Backend";

#define DR4_BACKEND_FUNCTION CreateDR4Backend

};

#endif

//---------------------------------------------------------------------------------------------------------
// container.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_HUI_CONTAINER
#define I_HUI_CONTAINER

#include "hui/event.hpp"
#include "hui/widget.hpp"

namespace hui {

class ContainerWidget : public Widget {

protected:

    virtual EventResult PropogateToChildren(Event &event) = 0;

    // TODO: reimplement methods using that

};

};

#endif

//---------------------------------------------------------------------------------------------------------
// widget.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_HUI_WIDGET
#define I_HUI_WIDGET

#include "dr4/math/vec2.hpp"
#include "dr4/texture.hpp"
#include "hui/event.hpp"

namespace hui {

class State;

class Widget : public dr4::Drawable {

protected:

    dr4::Vec2f relPos; ///< Relative to parent
    Widget *parent = nullptr;
    State *const state;
    dr4::Texture *const texture;
    bool textureIsInvalid;

    /// Redraws widget's texture
    virtual void Redraw() = 0;

    EventResult OnMouseDown(MouseDownEvent &evt);
    /// TODO : ... other handlers

public:

    Widget(State *state);

    // REVIEW : move implementations to cpp files?
    
    dr4::Vec2f GetRelPos() const { return relPos; };
    virtual void SetRelPos(dr4::Vec2f pos) { relPos = pos; };

    dr4::Vec2f GetSize() const { return texture->GetSize(); }
    virtual void SetSize(dr4::Vec2f size) { texture->SetSize(size); }

    virtual Widget *GetParent() const { return parent; };
    virtual void SetParent(Widget *parent_) { parent = parent_; }

    void DrawOn(dr4::Texture &texture) override {
        if (textureIsInvalid) {
            Redraw();
            textureIsInvalid = false;
        }
        texture.Draw(texture, relPos);
    }
};

}; // namespace hui

#endif // I_HUI_WIDGET

//---------------------------------------------------------------------------------------------------------
// event.hpp
//---------------------------------------------------------------------------------------------------------
#ifndef I_HUI_EVENT
#define I_HUI_EVENT

#include "dr4/math/vec2.hpp"

namespace hui {

enum class EventResult {
    UNHANDLED, HANDLED
};

class Widget;

struct Event {
    virtual EventResult Apply(Widget &widget) = 0;
};

struct MouseDownEvent : public Event {

    dr4::Vec2f relPos;
    virtual EventResult Apply(Widget &widget) override; // TODO: implement

};

struct IdleEvent : public Event {

    /// Time from some point of reference, used for deadlines, ....
    /// In seconds.
    double absTime;

    /// Time from previous IdleEvent, in seconds.
    double deltaTime;

    virtual EventResult Apply(Widget &widget) override; // TODO: implement
};

// TODO: other events
// MouseUpEvent, MouseMoveEvent, ..., IdleEvent

};

#endif

//---------------------------------------------------------------------------------------------------------
// texture.cpp
//---------------------------------------------------------------------------------------------------------
#include "texture.hpp"
#include <SFML/Graphics/RectangleShape.hpp>
#include <SFML/Graphics/RenderTexture.hpp>
#include <SFML/Graphics/Sprite.hpp>
#include <SFML/Graphics/Text.hpp>
#include <iostream>

namespace gfx {

void
Texture::SetSize( dr4::Vec2f size )
{
}

dr4::Vec2f
Texture::GetSize() const
{
    auto sf_size = impl_.getSize();

    return dr4::Vec2f( sf_size.x, sf_size.y );
}

float
Texture::GetWidth() const
{
    return GetSize().x;
}

float
Texture::GetHeight() const
{
    return GetSize().y;
}

void
Texture::Draw( const dr4::Rectangle& rect )
{
    sf::RectangleShape sf_rect;

    sf_rect.setSize( { rect.rect.size.x, rect.rect.size.y } );
    sf_rect.setPosition( { rect.rect.pos.x, rect.rect.pos.y } );
    sf_rect.setFillColor( { rect.fill.r, rect.fill.g, rect.fill.b, rect.fill.a } );
    sf_rect.setOutlineColor(
        { rect.borderColor.r, rect.borderColor.g, rect.borderColor.b, rect.borderColor.a } );
    sf_rect.setOutlineThickness( rect.borderThickness );

    impl_.draw( sf_rect );
}

void
Texture::Draw( const dr4::Text& text )
{

    sf::Text sf_text;

    sf_text.setCharacterSize( text.fontSize );
    sf_text.setFont( font_ );
    sf_text.setPosition( { text.pos.x, text.pos.y } );
    sf_text.setFillColor( { text.color.r, text.color.g, text.color.b, text.color.a } );
    sf_text.setString( text.text );

    impl_.draw( sf_text );
}

void
Texture::Draw( const dr4::Texture& texture, const dr4::Vec2f& pos )
{
    const Texture& my_texture = dynamic_cast<const Texture&>( texture );

    sf::Sprite sprite;
    sprite.setTexture( my_texture.impl_.getTexture() );
    sprite.setPosition( { pos.x, pos.y } );
    impl_.draw( sprite );
}

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// backend.cpp
//---------------------------------------------------------------------------------------------------------
#include "backend.hpp"
#include "window.hpp"

namespace gfx {

const std::string&
DR4Backend::Name() const
{
    static const std::string& name = "Хуй";

    return name;
}

dr4::Window*
DR4Backend::CreateWindow()
{
    return new Window();
}

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// window.cpp
//---------------------------------------------------------------------------------------------------------
#include "window.hpp"

namespace gfx {

void
Window::SetTitle( const std::string& title )
{
    title_ = title;
    impl_.setTitle( title_ );
}

const std::string&
Window::GetTitle() const
{
    return title_;
}

void
Window::SetSize( const dr4::Vec2f& size )
{
    size_ = size;
    impl_.setSize( { static_cast<uint>( size.x ), static_cast<uint>( size.y ) } );
}

dr4::Vec2f
Window::GetSize() const
{
    return dr4::Vec2f( size_.x, size_.y );
}

void
Window::Open()
{
    impl_.create( sf::VideoMode( size_.x, size_.y ), title_ );
    impl_.setFramerateLimit( 60 );
}

bool
Window::IsOpen() const
{
    return impl_.isOpen();
}

void
Window::Close()
{
    impl_.close();
}

void
Window::Clear( const dr4::Color& color )
{
    impl_.clear( sf::Color( color.r, color.g, color.b, color.a ) );
}

void
Window::Draw( const dr4::Texture& texture, dr4::Vec2f pos )
{
    const Texture& my_texture = dynamic_cast<const Texture&>( texture );

    sf::Sprite sprite;
    sprite.setTexture( my_texture.impl_.getTexture() );
    sprite.setPosition( { pos.x, pos.y } );
    impl_.draw( sprite );
}

void
Window::Display()
{
    impl_.display();
}

dr4::Texture*
Window::CreateTexture()
{
    return new Texture();
}

std::optional<dr4::Event>
Window::PollEvent()
{
    sf::Event sf_event;

    if ( !impl_.pollEvent( sf_event ) )
    {
        return std::nullopt;
    }

    return sfmlEventConvert( sf_event );
}

dr4::Event
Window::sfmlEventConvert( const sf::Event& sf_event )
{
    dr4::Event event;

    switch ( sf_event.type )
    {
        case sf::Event::Closed:
            event.type = dr4::Event::Type::QUIT;
            break;
        // case sf::Event::TextEntered:
        // event.type         = Event::TextEntered;
        // event.text.unicode = sf_event.text.unicode;
        // break;
        case sf::Event::KeyPressed:
            event.type = dr4::Event::Type::KEY_DOWN;
            // event.key.code = detail::fromSFML( sf_event.key.code );
            break;
        case sf::Event::KeyReleased:
            event.type = dr4::Event::Type::KEY_UP;
            // event.key.code = detail::fromSFML( sf_event.key.code );
            break;
        case sf::Event::MouseButtonPressed:
            event.type = dr4::Event::Type::MOUSE_DOWN;
            // event.mouse_button.button = detail::fromSFML( sf_event.mouseButton.button );
            // event.mouse_button.x      = sf_event.mouseButton.x;
            // event.mouse_button.y      = sf_event.mouseButton.y;
            break;
        case sf::Event::MouseButtonReleased:
            event.type = dr4::Event::Type::MOUSE_UP;
            // event.mouse_button.button = detail::fromSFML( sf_event.mouseButton.button );
            // event.mouse_button.x      = sf_event.mouseButton.x;
            // event.mouse_button.y      = sf_event.mouseButton.y;
            break;
        case sf::Event::MouseMoved:
            event.type = dr4::Event::Type::MOUSE_MOVE;
            // event.mouse_move.x = sf_event.mouseMove.x;
            // event.mouse_move.y = sf_event.mouseMove.y;
            break;
        default:
            event.type = dr4::Event::Type::UNKNOWN;
            break;
    }

    return event;
}

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// exception.hpp
//---------------------------------------------------------------------------------------------------------
#pragma once

#include "log.hpp"

namespace gfx {
namespace common {

#define GFX_API_CATCH( dr4_suffix )                                                                \
    catch ( const const std::bad_alloc& e )                                                        \
    {                                                                                              \
        log( "bad_alloc in " + __FILE__ + ":" ++__PRETTY_FUNTION_ + ":" __LINE__ );                \
    }

} // namespace common
} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// log.hpp
//---------------------------------------------------------------------------------------------------------
#pragma once

#include <iostream>

namespace gfx {
namespace common {

void
log( const std::string& msg )
{
    std::cerr << msg << std::endl;
}

} // namespace common
} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// window.hpp
//---------------------------------------------------------------------------------------------------------
#pragma once

#include "dr4/event.hpp"
#include "dr4/math/vec2.hpp"
#include "dr4/texture.hpp"
#include "dr4/window.hpp"
#include "texture.hpp"

#include <SFML/Graphics/Color.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/System/Vector2.hpp>
#include <SFML/Window.hpp>
#include <SFML/Window/Event.hpp>
#include <SFML/Window/Window.hpp>
#include <memory>
#include <optional>

namespace gfx {

class Window : public dr4::Window {
  public:
    ~Window() = default;

    virtual void
    SetTitle( const std::string& title ) override;

    virtual const std::string&
    GetTitle() const override;

    virtual void
    SetSize( const dr4::Vec2f& size ) override;

    virtual dr4::Vec2f
    GetSize() const override;

    virtual void
    Open() override;

    virtual bool
    IsOpen() const override;

    virtual void
    Close() override;

    virtual void
    Clear( const dr4::Color& color ) override;

    virtual void
    Draw( const dr4::Texture& texture, dr4::Vec2f pos ) override;

    virtual void
    Display() override;

    virtual dr4::Texture*
    CreateTexture() override;

    virtual std::optional<dr4::Event>
    PollEvent() override;

  private:
    dr4::Event
    sfmlEventConvert( const sf::Event& sf_event );

  private:
    dr4::Vec2f       size_;
    std::string      title_;
    sf::RenderWindow impl_;
};

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// backend.hpp
//---------------------------------------------------------------------------------------------------------
#pragma once

#include "misc/dr4_ifc.hpp"

namespace gfx {

class DR4Backend : public dr4::DR4Backend {
  public:
    ~DR4Backend() = default;

    virtual const std::string&
    Name() const override;
    virtual dr4::Window*
    CreateWindow() override;
};

extern "C" dr4::DR4Backend*
CreateDR4Backend();

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// texture.hpp
//---------------------------------------------------------------------------------------------------------
#pragma once

#include "dr4/math/vec2.hpp"
#include "dr4/texture.hpp"
#include <SFML/Graphics/RectangleShape.hpp>
#include <SFML/Graphics/RenderTexture.hpp>
#include <SFML/Graphics/Sprite.hpp>
#include <SFML/Graphics/Text.hpp>
#include <iostream>

namespace gfx {

class Window;

class Texture : public dr4::Texture {
    friend Window;

  public:
    ~Texture() = default;

    virtual void
    SetSize( dr4::Vec2f size ) override;

    virtual dr4::Vec2f
    GetSize() const override;

    virtual float
    GetWidth() const override;

    virtual float
    GetHeight() const override;

    virtual void
    Draw( const dr4::Rectangle& rect ) override;

    virtual void
    Draw( const dr4::Text& text ) override;

    virtual void
    Draw( const dr4::Texture& texture, const dr4::Vec2f& pos ) override;

  private:
    sf::Font          font_;
    sf::RenderTexture impl_;
};

} // namespace gfx

//---------------------------------------------------------------------------------------------------------
// CMakeCXXCompilerId.cpp
//---------------------------------------------------------------------------------------------------------
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L
#  if defined(__INTEL_CXX11_MODE__)
#    if defined(__cpp_aggregate_nsdmi)
#      define CXX_STD 201402L
#    else
#      define CXX_STD 201103L
#    endif
#  else
#    define CXX_STD 199711L
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  define CXX_STD _MSVC_LANG
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > 202002L
  "23"
#elif CXX_STD > 201703L
  "20"
#elif CXX_STD >= 201703L
  "17"
#elif CXX_STD >= 201402L
  "14"
#elif CXX_STD >= 201103L
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}

